jobscheduler.agent {
  task {
    # kill.script = "/path/to/kill-script"

    # Still unused:
    java.options = []
  }

  internal {
    # Don't touch!
    TaskRegisterActor.mailbox.mailbox-type = "com.sos.jobscheduler.agent.task.TaskRegisterActorMailbox"
  }
}

jobscheduler.order {
  stdout-stderr {
    # Maximum numbers of characters in OrderStdoutWritten and OrderStderrWritten events.
    chunk-size = 10000

    # Buffer for reading characters from stdout and stderr
    # (Java memory usage is four times this value (2 bytes per character, stdout and stderr)
    char-buffer-size = 4000

    # Delay and collect stdout and stderr in one chunk (one event) not longer than this duration.
    delay = 0.4s

    # After no stdout or stderr output for this duration, do not delay next OrderStdoutWritten or OrderStderrWritten.
    no-delay-after = 9999days  # never

    # Journal flush/sync delay for better throughput
    sync-delay = 0.1s
  }
}

jobscheduler.akka-ask-timeout = 1 minute

jobscheduler.akka {
  use-global-executor = true
  shutdown-timeout = 10s
}

jobscheduler.journal {
  # For every committed record written to journal, sync data with disk, i.e. force write to disk. Safe but maybe slow.
  sync = on

  # For testing of timing behavior: Don't sync, but sleep
  #simulate-sync = 20ms

  # Experimental: delay sync for more commits/sync
  delay = 0ms

  event-buffer-size = 1000

  # Duration of event writing after which JobScheduler writes a new journal file
  snapshot.period = 1hour

  # Aproximate maximum journal file size
  snapshot.when-bigger-than = 1GB

  snapshot.log-period = 30s
  snapshot.log-actor-limit = 10

  watch.keep-open = 100
  watch.index-size = 10000

  # JournalIndex holds one position for index-factor * (historic events or current commits of events)
  watch.index-factor = 100

  dispatcher {
    type = PinnedDispatcher
    executor = "thread-pool-executor"
  }
}

jobscheduler.auth.users {
  # Place your own users in file secret private/private.conf, using the following pattern:
  #  NAME = "sha256:PASSWORD" or "plain:PASSWORD"
}

jobscheduler.auth.session {
  timeout = 1 hour
}

jobscheduler.webserver {
  # When returning HTTP status 500 "Internal Server Error"
  # respond with the full Throwable message including causing Throwables.
  # May exhibit internals.
  verbose-error-messages = on

  auth {
    realm = "JobScheduler Agent"
    invalid-authentication-delay = 1s
    loopback-is-public = false
    get-is-public = false
    public = false
  }

  log {
    level = Debug
  }
}

jobscheduler.logging {
  actor = off
}

jobscheduler.termination {
  shutdown-hook-timeout = 10s

  # Must be shorter than shutdown-hook-timeout
  sigkill-after = 5s
}

jobscheduler.io-thread-pool {
  keep-alive = 60s
  minimum = 0
  maximum = unlimited
}

akka {
  # This configuration is for Akka. Descriptions are borrowed from http://akka.io.

  loggers = ["akka.event.slf4j.Slf4jLogger"]
  loglevel = DEBUG
  logging-filter = "akka.event.slf4j.Slf4jLoggingFilter"

  scheduler.tick-duration = 1s   # Or 100ms - With default (10ms under Windows), we have 1% CPU usage when idling

  # We have out own shutdown hook
  coordinated-shutdown.run-by-jvm-shutdown-hook = off

  # The guardian "/user" will use this class to obtain its supervisorStrategy.
  # It needs to be a subclass of akka.actor.SupervisorStrategyConfigurator.
  # In addition to the default there is akka.actor.StoppingSupervisorStrategy.
  actor.guardian-supervisor-strategy = akka.actor.StoppingSupervisorStrategy

  actor.default-dispatcher.fork-join-executor {
    parallelism-min = 1
    parallelism-factor = 1
  }
}

akka.http {
  # This configuration is for the Akka HTTP web server and client.
  # Descriptions are borrowed from http://doc.akka.io/docs/akka-http/current/scala/http/configuration.html.

  server {
    # The time after which an idle connection will be automatically closed.
    # Set to `infinite` to completely disable idle connection timeouts.
    idle-timeout = 65s

    # Defines the default time period within which the application has to
    # produce an HttpResponse for any given HttpRequest it received.
    # The timeout begins to run when the *end* of the request has been
    # received, so even potentially long uploads can have a short timeout.
    # Set to `infinite` to completely disable request timeout checking.
    #
    # Make sure this timeout is smaller than the idle-timeout, otherwise,
    # the idle-timeout will kick in first and reset the TCP connection
    # without a response.
    #
    # If this setting is not `infinite` the HTTP server layer attaches a
    # `Timeout-Access` header to the request, which enables programmatic
    # customization of the timeout period and timeout response for each
    # request individually.
    request-timeout = 60s

    # Enables/disables the returning of more detailed error messages to
    # the client in the error response.
    # Should be disabled for browser-facing APIs due to the risk of XSS attacks
    # and (probably) enabled for internal or non-browser APIs.
    # Note that akka-http will always produce log messages containing the full
    # error details.
    verbose-error-messages = on
  }

  host-connection-pool {
    # The maximum number of times failed requests are attempted again,
    # (if the request can be safely retried) before giving up and returning an error.
    # Set to zero to completely disable request retries.
    max-retries = 0

    # The maximum number of open requests accepted into the pool across all
    # materializations of any of its client flows.
    # Protects against (accidentally) overloading a single pool with too many client flow materializations.
    # Note that with N concurrent materializations the max number of open request in the pool
    # will never exceed N * max-connections * pipelining-limit.
    # Must be a power of 2 and > 0!
    #max-open-requests = 32

    # The time after which an idle connection pool (without pending requests)
    # will automatically terminate itself. Set to `infinite` to completely disable idle timeouts.
    #idle-timeout = 30 s
    idle-timeout = 65s
  }

  client {
    # The time period within which the TCP connecting process must be completed.
    connecting-timeout = 30s
  }
}
