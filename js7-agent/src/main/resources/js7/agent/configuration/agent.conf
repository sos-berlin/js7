js7.agent {
  task {
    # kill.script = "/path/to/kill-script"

    signed-script-injection-allowed = no

    # Still unused:
    java.options = []
  }

  internal {
    # Don't touch!
    TaskRegisterActor.mailbox.mailbox-type = "js7.agent.task.TaskRegisterActorMailbox"
  }
}

js7.order {
  stdout-stderr {
    # Maximum numbers of characters in OrderStdoutWritten and OrderStderrWritten events.
    chunk-size = 10000

    # Buffer for reading characters from stdout and stderr
    # (Java memory usage is four times this value (2 bytes per character, stdout and stderr)
    char-buffer-size = 4000

    # Delay and collect stdout and stderr in one chunk (one event) not longer than this duration.
    delay = 0.4s

    # After no stdout or stderr output for this duration, do not delay next OrderStdoutWritten or OrderStderrWritten.
    no-delay-after = 9999days  # never

    # Longer journal commit delay gives better journal throughput,
    # shorter delay gives shorter event latency.
    commit-delay = 0.1s
  }
}

js7.akka {
  use-js7-thread-pool = on
  shutdown-timeout = 10s
  ask-timeout = 1 hour
  actor-message-log-level = None
}

js7.journal {
  # For every committed record written to journal, sync data with disk, i.e. force write to disk. Safe but maybe slow.
  sync = off

  # For testing of timing behavior of a slow magnetic disk: Don't sync, but sleep
  #simulate-sync = 20ms

  # Delay before sync only, for more commits per sync and to reduce disk usage
  sync-delay = 50ms

  # Delay sync or flush, for more commits per sync/flush
  delay = 0ms

  event-buffer-size = 1000

  # Additional slow consistency test:
  slow-check-state = false

  # To switch to the old behaviour with snapshost managed by JournaledActors: false
  use-journaled-state-as-snapshot = true

  # Duration of event writing after which JS7 writes a new journal file
  snapshot.period = 1hour

  # Approximate maximum journal file size
  snapshot.when-bigger-than = 1GB

  snapshot.log-period = 30s
  snapshot.log-actor-limit = 10

  watch.keep-open = 100
  watch.index-size = 10000

  # JournalIndex holds one position for index-factor * (historic events or current commits of events)
  watch.index-factor = 100

  ack-warn-durations = [ 5s, 5.s, 10.s ]

  dispatcher {
    type = PinnedDispatcher
    executor = "thread-pool-executor"
  }

  # Remove unused journal files. This can be suppressed with remove-obsolete-files=false.
  remove-obsolete-files = true

  # UserIDs of user allows to send MasterCommand.ReleaseEvents.
  # JS7 keeps track of latest ReleaseEvents of each user and deletes events to the minimum of all.
  # AGENT DOES NOT USE THIS
  users-allowed-to-release-events = []
}

js7.auth.users {
  # Place your own users in file secret private/private.conf, using the following pattern:
  #  NAME = "sha256:PASSWORD" or "plain:PASSWORD"
}

js7.auth.session {
  timeout = 1 hour
}

js7.webserver {
  # When returning HTTP status 500 "Internal Server Error"
  # respond with the full Throwable message including causing Throwables.
  # May exhibit internals.
  verbose-error-messages = on

  shutdown-timeout = 10s

  auth {
    realm = "JobScheduler JS7 Agent Server"
    invalid-authentication-delay = 1s

    # Warning: loopback-is-pubic = on would open JS7
    # for everyone with access to a loopback interface (127.0.0.1)
    # This may be your local reverse proxy which routes requests
    # from the world to JS7.
    loopback-is-public = off

    # Warning: get-is-public = on would allow everyone doing HTTP GET.
    # That means read access would be allowed for everyone.
    get-is-public = off

    # Warning: public = on would allow everyone
    # doing nearly everything with JS7.
    # Do not do that!
    public = off
  }

  log {
    level = Debug
    error-level = Debug
    500-level = Warn
    response = on
  }

  services {
    event {
      streaming {
        chunk-timeout = 24h
        delay = 20ms
      }
    }
  }
}

js7.termination {
  shutdown-hook-timeout = 10s

  # Must be shorter than shutdown-hook-timeout
  sigkill-after = 5s
}

js7.thread-pools {
  standard {
    # Number of threads.
    # parallelism = 8 means 8 threads
    # parallelism = 1.5x means one and a half thread per processor (Java's availableProcessors), rounded up
    parallelism = 1x

    # Maximum number of threads, including blocking ones
    maximum = 1000
  }

  io {
    keep-alive = 5 minutes
    minimum = 0
    maximum = unlimited
  }
}

js7.monix.tailrecm-limit = 1000

akka {
  # This configuration is for Akka. Descriptions are borrowed from http://akka.io.

  loggers = ["akka.event.slf4j.Slf4jLogger"]
  loglevel = DEBUG
  stdout-loglevel = off
  logging-filter = "akka.event.slf4j.Slf4jLoggingFilter"
  logger-startup-timeout = 30s

  scheduler.tick-duration = 200ms   # Or 100ms - With default (10ms under Windows), we have 1% CPU usage when idling

  # We have our own shutdown hook
  coordinated-shutdown.run-by-jvm-shutdown-hook = off

  # The guardian "/user" will use this class to obtain its supervisorStrategy.
  # It needs to be a subclass of akka.actor.SupervisorStrategyConfigurator.
  # In addition to the default there is akka.actor.StoppingSupervisorStrategy.
  actor.guardian-supervisor-strategy = akka.actor.StoppingSupervisorStrategy

  actor.default-dispatcher.fork-join-executor {
    parallelism-min = 1
    parallelism-factor = 1
  }

  http {
    server {
      # The time after which an idle connection will be automatically closed.
      # Set to `infinite` to completely disable idle connection timeouts.
      # Default: idle-timeout = 60 s
      #idle-timeout = 65s
      idle-timeout = 16 minutes

      # Defines the default time period within which the application has to
      # produce an HttpResponse for any given HttpRequest it received.
      # The timeout begins to run when the *end* of the request has been
      # received, so even potentially long uploads can have a short timeout.
      # Set to `infinite` to completely disable request timeout checking.
      #
      # Make sure this timeout is smaller than the idle-timeout, otherwise,
      # the idle-timeout will kick in first and reset the TCP connection
      # without a response.
      #
      # If this setting is not `infinite` the HTTP server layer attaches a
      # `Timeout-Access` header to the request, which enables programmatic
      # customization of the timeout period and timeout response for each
      # request individually.
      # Default: request-timeout = 20 s
      request-timeout = 15 minutes

      # Enables/disables the returning of more detailed error messages to
      # the client in the error response.
      # Should be disabled for browser-facing APIs due to the risk of XSS attacks
      # and (probably) enabled for internal or non-browser APIs.
      # Note that akka-http will always produce log messages containing the full
      # error details.
      # Default: verbose-error-messages = off
      verbose-error-messages = on
    }

    host-connection-pool {
      # The "new" pool implementation will fail a connection early and clear the slot if a response entity was not
      # subscribed during the given time period after the response was dispatched. In busy systems the timeout might be
      # too tight if a response is not picked up quick enough after it was dispatched by the pool.
      # Default: response-entity-subscription-timeout = 1s
      response-entity-subscription-timeout = 10s
    }
  }
}
